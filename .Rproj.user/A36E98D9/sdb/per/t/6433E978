{
    "contents" : "# check hydrological budget GEOtop 3d simulation\n# P = Q + E + dS\n# P - Precipitation, Q - Runoff, E - Evapotranspiration, dS - Change in Storage\n# \n# # test\n#  wpath <- \"Y:/Simulation_GEOtop_1_225_ZH/Vinschgau/SimTraining/BrJ/Mazia/Discharge/WG1_005/\"\n#  wpath <- \"Y:/Simulation_GEOtop_2_0_GIT/Shalini/umvoti_011/\"\n# # Q observed\n#  library(zoo)\n#  library(chron)\n#  Q_obs <- read.csv2(\"H:/Projekte/HiResAlp/06_Workspace/BrJ/02_data/discharge/WG1_Saldur.csv\",header=T)\n#  datetime <- chron(dates. = substr(Q_obs$Time,1,10),times. = paste(substr(Q_obs$Time,12,17),\":00\",sep=\"\"),\n#                    format = c(dates=\"d.m.y\", times=\"h:m:s\"), out.format = c(dates=\"d/m/y\", times=\"h:m:s\"))\n#  datetime <- as.POSIXct(datetime)\n#  Q_obs_data <- zoo(x = as.numeric(as.character((Q_obs$Q.m3.s))), order.by = datetime)  \n#  Q_obs <- \"hour\"\n#  soil_files <- FALSE\n# wpath       working path\n# Q_obs       observed discharge available in time step \"hour\" or \"day\"; not available \"n\"\n# Q_obs_data  zoo-object, observed discharge; m^3/s\n\n# # # geotopbricks version\n# # # run with new / github version\n# library(devtools)\n# remove.packages(\"geotopbricks\")\n# install_github(repo = \"ecor/geotopbricks\")\n \nGEOtop_CheckHydroBudget <- function(wpath, Q_obs, Q_obs_data, soil_files, list_file=\"listpoints.txt\")\n{\n# load libraries \n#  require(geotopbricks)\n# \n#  require(zoo)\n#  require(chron)\n#  require(hydroGOF)\n#  require(raster)\n\n\n# get simulation domain - area [m^2] from lancover map\n  lc_map <- get.geotop.inpts.keyword.value(keyword = \"LandCoverMapFile\", raster = T, wpath=wpath)\n  # spatial resolution of raster\n  res <- res(x = lc_map)\n  # valid grid cells\n  validVAL  <- sum(!is.na(lc_map@data@values))\n  # calculate basin area in m^2\n  basinArea <- validVAL*res[1]*res[2]\n\n# extract start and end of simulation\n  start <- get.geotop.inpts.keyword.value(\"InitDateDDMMYYYYhhmm\",date=TRUE,wpath=wpath,\n                                          tz=\"UTC\")\n  end <- get.geotop.inpts.keyword.value(\"EndDateDDMMYYYYhhmm\",date=TRUE,wpath=wpath,tz=\"UTC\")\n  \n# get x- , y-coordinates of output points\n  #if (file.exists(file.path(wpath,\"listpoints.txt\")))\n  if (!is.null(list_file))\n  {\n    listpoints <- read.csv(file.path(wpath,list_file), header = T)\n    xpoints <- listpoints$xcoord; ypoints <- listpoints$ycoord\n  } else {\n    xpoints <- get.geotop.inpts.keyword.value(\"CoordinatePointX\",wpath=wpath,numeric=T)\n    ypoints <- get.geotop.inpts.keyword.value(\"CoordinatePointY\",wpath=wpath,numeric=T)\n  }\n\n# get levels, number of output points\n  if (!is.null(xpoints))  level <- 1:length(xpoints) else level <- NULL\n  \n  # read basin file \n  # basin time scale is daily\n  basin_name <- get.geotop.inpts.keyword.value(\"BasinOutputFile\", wpath=wpath)\n  basin_data <- read.csv(file = paste(wpath, basin_name, \".txt\", sep=\"\"), header=T)\n\n  datetime <- chron(dates. = substr(basin_data$Date12.DDMMYYYYhhmm.,1,10),\n                    times. = paste(substr(basin_data$Date12.DDMMYYYYhhmm.,12,17),\":00\",sep=\"\"),\n                    format = c(dates=\"d/m/y\", times=\"h:m:s\"), out.format = c(dates=\"d/m/y\", times=\"h:m:s\"))\n  basin_timestep <- as.numeric(diff(datetime)[1])\n\n  datetime <- as.POSIXct(datetime)\n\n  if (basin_timestep < 1)\n  {\n    # aggregate to daily mean\n    skip <- which(format(datetime,\"%H\")==\"02\")[1]\n    basin_xts  <- zoo(x = basin_data[-c(1:skip),-c(1:5)], order.by = datetime[-c(1:skip)])\n    date <- as.Date(time(basin_xts))\n    basin_xts <- aggregate(x = basin_xts, by = date, FUN = mean)\n    \n  } else if (basin_timestep == 1) {\n    date <- as.Date(datetime)\n    basin_xts  <- zoo(x = basin_data[,-c(1:5)], order.by = date)\n  } else {\n    print (\"time step of basin file > 1 day, check geotop.inpts file for basinAll keyword.\")\n  }\n\n  date <- time(basin_xts)\n\n#1 Areal Precipitation (P)\n  \n  # extract from basin file\n  if (basin_timestep == 1) {\n    P_rain <- basin_xts$Prain_above_canopy.mm.\n    P_snow <- basin_xts$Prain_above_canopy.mm..1\n  }\n  if (basin_timestep < 1){\n    P_rain <- basin_xts$Prain_above_canopy.mm. *24\n    P_snow <- basin_xts$Prain_above_canopy.mm..1 *24\n  } \n\n  P <- P_rain + P_snow\n    \n  # Intercept Storage = (P_above-P_below) - Transpiration\n  # not true... \n  S_Intercept <- (basin_xts$Prain_above_canopy.mm.-basin_xts$Prain_below_canopy.mm.) + \n    (basin_xts$Prain_above_canopy.mm..1-basin_xts$Psnow_below_canopy.mm.) - basin_xts$Transpiration_canopy.mm.\n  \n  meteo <- merge(basin_xts$Tair.C., P, P_snow, S_Intercept)\n  \n  YsumsP <- aggregate(P, by = format(time(P),\"%Y\"), FUN = sum, na.rm=T)\n  YsumsS <- aggregate(P_snow, by = format(time(P_snow),\"%Y\"), FUN = sum, na.rm=T)\n  \n#2 Discharge (Q)\n  \n  # read discharge data, aggregate daily if output is not daily\n  discharge_name <- get.geotop.inpts.keyword.value(\"DischargeFile\", wpath=wpath)\n  discharge_data <- read.csv(file = paste(wpath,discharge_name,\".txt\",sep=\"\"), header=T)\n  \n  datetime <- chron(dates. = substr(discharge_data$DATE.day.month.year.hour.min.,1,10),\n                    times. = paste(substr(discharge_data$DATE.day.month.year.hour.min.,12,17),\":00\",sep=\"\"),\n                    format = c(dates=\"d/m/y\", times=\"h:m:s\"), out.format = c(dates=\"d/m/y\", times=\"h:m:s\"))\n  \n  discharge_timestep <- as.numeric(diff(datetime)[1])\n\n  datetime <- as.POSIXct(datetime)\n  \n  if (discharge_timestep < 1)\n  {\n    # aggregate to daily mean\n    skip <- which(format(datetime,\"%H\")==\"02\")[1]\n    discharge_hourly <- zoo(x = discharge_data[-c(1:skip),-c(1:4)], order.by = datetime[-c(1:skip)])\n    discharge_date <- as.Date(time(discharge_hourly))\n    discharge_daily <- aggregate(x = discharge_hourly, by = discharge_date, FUN = mean)\n    Q_sim <- discharge_daily\n    \n  } else if (discharge_timestep == 1) {\n    discharge_date <- as.Date(x = discharge_data$DATE.day.month.year.hour.min., format = \"%d/%m/%Y %H:%M\")\n    discharge_daily <- zoo(x = discharge_data[,-c(1:4)], order.by = discharge_date)\n    Q_sim <- discharge_daily\n  } else {\n    print (\"time step of basin file > 1 day, check geotop.inpts file for basinAll keyword.\")\n  }\n  \n  v_channel <- discharge_daily$Vchannel.m3.\n  v_channel_mm <- v_channel / basinArea * 1000\n\n  Q_out <- discharge_daily$Qoutlandsup.m3.s. + discharge_daily$Qoutlandsub.m3.s. + discharge_daily$Qoutbottom.m3.s.\n  Q_out_mm_day <- Q_out * (60*60*24) / basinArea * 1000\n  \n\n  # read observed discharge\n  if (Q_obs==\"hour\")\n  {\n    discharge_hourly <- merge(Q_obs_data, discharge_hourly)      \n    discharge_daily  <- aggregate(x = discharge_hourly,\n                                  by = as.Date(time(discharge_hourly)), FUN = mean)\n  } else if (Q_obs==\"day\")\n  {\n    discharge_daily <- merge(Q_obs_data, discharge_daily)  \n  } else {\n    print(\"no observed discharge data available\")\n  }\n\n  discharge_month  <- aggregate(x = discharge_daily, \n                                by = as.yearmon(time(discharge_daily)), FUN=mean)\n\n# total discharge at outlet in m^3/s\n\n  if (Q_obs==\"hour\" | Q_obs==\"day\") {\n    Q_tot <- discharge_daily[,c(1,2)]\n    # total basin discharge in mm\n    # m^3/s -> m^3/d -> m -> mm\n    Q_tot_mm <- Q_tot * (60*60*24) / basinArea * 1000\n    Q_sim_mm <- Q_sim$Qtot.m3.s. * (60*60*24) / basinArea * 1000\n    Q_obs_mm <- Q_tot_mm$Q_obs_data\n  } else {\n    Q_tot <- discharge_daily$Qtot.m3.s.\n    # total basin discharge in mm\n    # m^3/s -> m^3/d -> m -> mm\n    Q_tot_mm <- Q_tot * (60*60*24) / basinArea * 1000\n    Q_sim_mm <- Q_tot_mm\n  }\n\n#   rat_Q_P  <- Q_tot_mm/P \n#   rat_Q_P[is.infinite(rat_Q_P)] <- NA\n#   rat_Q_P[rat_Q_P>100] <- 100\n\n#3 Evapotranspiration E\n  if (basin_timestep == 1) {\n    Evap_surface <- basin_xts$Evap_surface.mm.\n    Trans_canopy <- basin_xts$Transpiration_canopy.mm.\n  }\n\n  if (basin_timestep < 1){\n    Evap_surface <- basin_xts$Evap_surface.mm. *24\n    Trans_canopy <- basin_xts$Transpiration_canopy.mm. *24\n  }\n\n    ET <- Evap_surface + Trans_canopy\n\n#4 Storage (not cumulated!) S\n\n  Intercept_dS <- zoo(c(0,diff(S_Intercept)), date)\n  totalIntercept_S <- S_Intercept\n\n# soil water storage\n\n# soil saturation and layer thickness from soil input \n  if (soil_files) {\n    nr_soiltypes <- get.geotop.inpts.keyword.value(keyword=\"SoilLayerTypes\", wpath=wpath, numeric=TRUE)\n    soil_map <- get.geotop.inpts.keyword.value(keyword = \"SoilMapFile\", raster = T, wpath=wpath, isNA = -9999)\n    soil_map@data@values[soil_map@data@values==-9999] <- NA\n    soil_type_summary <- summary(as.factor(soil_map@data@values))\n    soil_type_ratio   <- soil_type_summary[!names(soil_type_summary)==\"NA's\"] / sum(soil_type_summary[!names(soil_type_summary)==\"NA's\"])\n    \n    soil_input <- get.geotop.inpts.keyword.value(keyword=\"SoilParFile\", wpath=wpath, data.frame=TRUE, \n                                                 level = 1:nr_soiltypes)\n    \n    soil_thickness_header <- get.geotop.inpts.keyword.value(keyword=\"HeaderSoilDz\", wpath=wpath)\n    soil_saturation_header <- get.geotop.inpts.keyword.value(keyword=\"HeaderThetaSat\", wpath=wpath)\n    \n    if (is.list(soil_input)) {\n      soil_thickness <- soil_input[[1]][,soil_thickness_header]\n      \n    saturation_ratio_mat <- c()\n    for (i in names(soil_type_ratio))\n    {\n      saturation_ratio_mat <- cbind(saturation_ratio_mat, soil_input[[as.integer(i)]][,soil_saturation_header] * soil_type_ratio[i]) \n    }\n    soil_saturation <- rowSums(saturation_ratio_mat)\n    } else {\n      soil_thickness <- soil_input[,soil_thickness_header]\n      soil_saturation <- soil_input[,soil_saturation_header]\n    }\n  \n  } else {\n    soil_saturation <- get.geotop.inpts.keyword.value(keyword=\"ThetaSat\", wpath=wpath, numeric=T)\n    soil_thickness <- get.geotop.inpts.keyword.value(\"SoilLayerThicknesses\", numeric = T, wpath=wpath)\n  }\n\n  nlayers <- length(soil_thickness)\n\n#   # output depth in mm\n#   soil_head <- diff(c(0,cumsum(soil_thickness)))/2 + c(0,cumsum(soil_thickness))[-length(soil_thickness)-1]\n# \n#   soil_header <- c()\n#   for (i in 1:length(soil_head))\n#   {\n#     if (ceiling(soil_head[i])==soil_head[i]) {\n#       soil_header[i] <- paste(\"X\", soil_head[i], \".000000\", sep=\"\")\n#     } else {\n#       soil_header[i] <- paste(\"X\", soil_head[i], \"00000\", sep=\"\")  }     \n#   }\n\n# soil liquid water storage\n  name_soilliq <- get.geotop.inpts.keyword.value(keyword = \"SoilLiqContentTensorFile\", wpath=wpath)\n  \n  if (!is.null(name_soilliq))\n  {\n    pointerMAPS_soilliq <- pointer.to.maps.xyz.time(wpath, map.prefix = name_soilliq, \n                                                    suffix = \"L%04dN%04d.asc\", \n                                                    zoo.index = NULL, ntime=length(date), \n                                                    nlayers=nlayers)\n    \n    SMCliq_mm_0 <- sapply(X = pointerMAPS_soilliq, FUN = function(x) {\n      map1 <- read.asciigrid(x[1])\n      mean_total_storage <- mean(map1@data[,1], na.rm=T)\n    }) * soil_thickness\n\n    diffSMCliq <- sapply( X = pointerMAPS_soilliq, FUN = function(x) {\n      map1 <- read.asciigrid(x[1])\n      out  <- c()\n      for (i in 2:length(x)) {\n        map2 <- read.asciigrid(x[i])\n        diff <- map2@data[,1] - map1@data[,1]\n        # mean basin change in soil liquid water content\n        out[i] <- mean(diff, na.rm=T)\n        map1 <- map2\n      }\n      out[1] <- 0\n      return(out)\n    } )\n#    colnames(diffSMCliq) <- paste(\"Layer\", 1:nlayers, sep=\"\")\n    diffSMCliq_mm <- t(t(diffSMCliq)*soil_thickness)\n    \n    totalSMCliq_mm <- diffSMCliq_mm\n    totalSMCliq_mm[1,] <- SMCliq_mm_0\n    totalSMCliq_mm <- apply(totalSMCliq_mm,2,cumsum)\n    \n    diffSMCliq_mm <- zoo(diffSMCliq_mm, date)\n    totalSMCliq_mm <- zoo(totalSMCliq_mm, date)\n    \n    diffSMCliq_mm_column <- zoo(rowSums(diffSMCliq_mm),date)\n    totalSMCliq_mm_column <- zoo(rowSums(totalSMCliq_mm),date)\n  }\n\n  soil_column <- cumsum(c(0, soil_thickness))\n  soil_spez   <- c()\n\n  for (i in 1:length(soil_thickness))\n  {\n    soil_spez[i] <- paste(soil_column[i],\"-\",soil_column[i+1],\"mm\",sep=\" \")\n  }\n\n  layer_saturation <- soil_thickness * soil_saturation\n\n# soil ice storage\n  name_soilice <- get.geotop.inpts.keyword.value(keyword = \"SoilIceContentTensorFile\", wpath=wpath)\n\n  if (!is.null(name_soilice))\n  {\n    pointerMAPS_soilice <- pointer.to.maps.xyz.time(wpath, map.prefix = name_soilice, \n                                                   suffix = \"L%04dN%04d.asc\", \n                                                   zoo.index = NULL, ntime=length(date), \n                                                   nlayers=nlayers)\n    \n    SMCice_mm_0 <- sapply(X = pointerMAPS_soilice, FUN = function(x) {\n      map1 <- read.asciigrid(x[1])\n      mean_total_storage <- mean(map1@data[,1], na.rm=T)\n    }) * soil_thickness\n    \n    diffSMCice <- sapply( X = pointerMAPS_soilice, FUN = function(x) {\n      map1 <- read.asciigrid(x[1])\n      out  <- c()\n      for (i in 2:length(x)) {\n        map2 <- read.asciigrid(x[i])\n        diff <- map2@data[,1] - map1@data[,1]\n        # mean basin change in soil ice content\n        out[i] <- mean(diff, na.rm=T)\n        map1 <- map2\n      }\n      out[1] <- 0\n      return(out)\n    } )\n#    colnames(diffSMCice) <- paste(\"Layer\", 1:nlayers, sep=\"\")\n    diffSMCice_mm <- t(t(diffSMCice)*soil_thickness)\n    \n    totalSMCice_mm <- diffSMCice_mm\n    totalSMCice_mm[1,] <- SMCice_mm_0\n    totalSMCice_mm <- apply(totalSMCice_mm,2,cumsum)\n    \n    diffSMCice_mm <- zoo(diffSMCice_mm, date)\n    totalSMCice_mm <- zoo(totalSMCice_mm, date)\n    \n    diffSMCice_mm_column <- zoo(rowSums(diffSMCice_mm),date)\n    totalSMCice_mm_column <- zoo(rowSums(totalSMCice_mm),date)\n  }\n\n  # total SMC\n  if (!is.null(name_soilice) & !is.null(name_soilliq))\n  {\n    totalSMC_mm <- totalSMCice_mm + totalSMCliq_mm\n    totalSMC_mm_column <- totalSMCice_mm_column + totalSMCliq_mm_column\n    \n    diffSMC_mm <- diffSMCice_mm + diffSMCliq_mm\n    diffSMC_mm_column <- diffSMCice_mm_column + diffSMCliq_mm_column\n    \n    absSMC_mm <- diffSMC_mm \n    \n    Intercept_dS <- merge(Intercept_dS, SMC_dS=diffSMC_mm_column)\n    totalIntercept_S <- merge(totalIntercept_S, SMC_S = totalSMC_mm_column)\n  } else if (!is.null(name_soilliq)) {\n    totalSMC_mm <- totalSMCliq_mm\n    totalSMC_mm_column <- totalSMCliq_mm_column\n    \n    diffSMC_mm <- diffSMCliq_mm\n    diffSMC_mm_column <- diffSMCliq_mm_column\n    \n    absSMC_mm <- diffSMC_mm \n    \n    Intercept_dS <- merge(Intercept_dS, SMC_dS=diffSMC_mm_column)\n    totalIntercept_S <- merge(totalIntercept_S, SMC_S = totalSMC_mm_column)\n  }\n\n# snow and ice storage\n  name_swe     <- get.geotop.inpts.keyword.value(keyword = \"SWEMapFile\", wpath=wpath)\n  \n  if (!is.null(name_swe))\n  {\n    \n    glacier <- get.geotop.inpts.keyword.value(keyword = \"InitGlacierDepthMapFile\", wpath=wpath, raster=T)\n    if (!is.null(glacier)) {\n      glacier_cells <- which(glacier@data$values!=0)\n    } else if (!is.null(get.geotop.inpts.keyword.value(keyword = \"InitSWEMapFile\", wpath=wpath))) {\n      glacier <- get.geotop.inpts.keyword.value(keyword = \"InitSWEMapFile\", wpath=wpath, raster=T)\n      glacier_cells <- which(glacier@data@values!=0)\n    } else {\n      print(\"No glacier input provided. Not possible to distinguish between snow and ice SWE\")\n    }\n    \n    pointerMAPS_swe <- pointer.to.maps.xyz.time(wpath, map.prefix = name_swe, \n                                                suffix = \"N%04d.asc\", \n                                                zoo.index = NULL, ntime=1,\n                                                nlayers=length(date))\n    \n    pointerMAPS_swe <- unlist(pointerMAPS_swe)\n    \n    map1 <- read.asciigrid(pointerMAPS_swe[1])\n    SWE_mm_0 <- mean(map1@data[,1], na.rm=T)\n    \n    if (!is.null(glacier))\n    {\n      SWE_mm_0_glacier <- mean(map1@data[glacier_cells,1], na.rm=T)\n      SWE_mm_0_snow    <- mean(map1@data[-glacier_cells,1], na.rm=T)\n      \n      diffSWE_mm_glacier  <- c()\n      diffSWE_mm_snow  <- c()\n      \n      diffSWE_mm_glacier[1] <- 0\n      diffSWE_mm_snow[1] <- 0\n    }\n    \n    diffSWE_mm  <- c()\n    diffSWE_mm[1] <- 0\n    \n    for (i in 2:length(pointerMAPS_swe)) \n    {\n      map2 <- read.asciigrid(pointerMAPS_swe[i])\n      diff <- map2@data[,1] - map1@data[,1]\n      # mean basin change in snow water equivalent (including glaciers --> old snow)\n      diffSWE_mm[i] <- mean(diff, na.rm=T)\n      \n      if (!is.null(glacier)) \n      {\n      # sum of glacier / snow melt in the whole basin and normalized/meaned over basin area\n        diffSWE_mm_glacier[i] <- sum(diff[glacier_cells], na.rm=T) / validVAL\n        diffSWE_mm_snow[i]    <- sum(diff[-glacier_cells], na.rm=T) / validVAL\n      }\n      \n      map1 <- map2\n    }\n    \n    #total SWE storage (glacier + snow)\n    totalSWE_mm <- diffSWE_mm\n    totalSWE_mm[1] <- SWE_mm_0\n    totalSWE_mm <- cumsum(totalSWE_mm)\n    \n    diffSWE_mm <- zoo(diffSWE_mm, date)\n    totalSWE_mm <- zoo(totalSWE_mm, date)\n\n    Intercept_dS <- merge(Intercept_dS, SWE_dS=diffSWE_mm)\n    totalIntercept_S <- merge(totalIntercept_S, SWE_S = totalSWE_mm)\n    \n    if (!is.null(glacier))\n    {\n      # glacier\n      totalSWE_mm_glacier <- diffSWE_mm_glacier\n      totalSWE_mm_glacier[1] <- SWE_mm_0_glacier\n      totalSWE_mm_glacier <- cumsum(totalSWE_mm_glacier)\n      \n      diffSWE_mm_glacier <- zoo(diffSWE_mm_glacier, date)\n      totalSWE_mm_glacier <- zoo(totalSWE_mm_glacier, date)\n      \n      # snow\n      totalSWE_mm_snow <- diffSWE_mm_snow\n      totalSWE_mm_snow[1] <- SWE_mm_0_snow\n      totalSWE_mm_snow <- cumsum(totalSWE_mm_snow)\n      \n      diffSWE_mm_snow <- zoo(diffSWE_mm_snow, date)\n      totalSWE_mm_snow <- zoo(totalSWE_mm_snow, date)\n    }\n  }\n\n# Land Surface Storage\n  name_hsup <- get.geotop.inpts.keyword.value(keyword = \"LandSurfaceWaterDepthMapFile\", wpath=wpath)\n  \n  if (!is.null(name_hsup))\n  {\n    pointerMAPS_hsup <- pointer.to.maps.xyz.time(wpath, map.prefix = name_hsup, \n                                                 suffix = \"N%04d.asc\", \n                                                 zoo.index = NULL, ntime=1,\n                                                 nlayers=length(date))\n    \n    pointerMAPS_hsup <- unlist(pointerMAPS_hsup)\n    \n    map1 <- read.asciigrid(pointerMAPS_hsup[1])\n    HSUP_mm_0 <- mean(map1@data[,1], na.rm=T)\n    diffHSUP_mm  <- c()\n    diffHSUP_mm[1] <- 0\n    for (i in 2:length(pointerMAPS_hsup)) \n    {\n      map2 <- read.asciigrid(pointerMAPS_hsup[i])\n      diff <- map2@data[,1] - map1@data[,1]\n      # mean basin change in snow water equivalent (including glaciers --> old snow)\n      diffHSUP_mm[i] <- mean(diff, na.rm=T)\n      map1 <- map2\n    }\n    diffHSUP_mm <- zoo(diffHSUP_mm, date)\n    totalHSUP_mm <- diffHSUP_mm\n    totalHSUP_mm[1] <- HSUP_mm_0\n    totalHSUP_mm <- cumsum(totalHSUP_mm)\n    \n    Intercept_dS <- merge(Intercept_dS, HSUP_dS=diffHSUP_mm)\n    totalIntercept_S <- merge(totalIntercept_S, HSUP_S = totalHSUP_mm)\n  }\n\n# \n\n  Intercept_dS <- merge(Intercept_dS, Hchannel_dS=diff(v_channel_mm))\n  \n  totalIntercept_S <- merge(totalIntercept_S, Hchannel_S = v_channel_mm)\n  totalIntercept_S <- totalIntercept_S[!is.na(totalIntercept_S),]\n                                       \n  dS <- Intercept_dS[,-1]\n  totalStorage <- totalIntercept_S[,-1]\n\n  delta_S <- zoo(rowSums(dS),date)\n  S <- zoo(rowSums(totalStorage),date)\n\n#------------------------\n# plotting\n\ntext <- c(\"YEAR: Precip (mm) , Snow (%)\", paste(time(YsumsS), \": \", round(YsumsP), \",\", round(YsumsS/YsumsP*100), sep=\"\"))\n  \npdf(paste(wpath,\"Ppartitioning.pdf\",sep=\"\"), width = 21)\n\n#1 meteo data | partitioning rain / snow\n\n  if (Q_obs==\"hour\" | Q_obs==\"day\") {\n    meteo_Q <- merge(meteo[,c(1,2,3)], discharge_daily[,c(1,2)])\n    plot.zoo(meteo_Q, ylab=c(\"Tair [°C]\", \"P [mm]\", \"Q [m^3/s]\"), screens = c(1,2,2,3,3), main=\"Basin Mean Meteo , Discharge\", \n             type=c(\"l\",\"h\",\"h\",\"l\", \"l\"), col=c(grey(.2,.5), rgb(0,0,1,.75), rgb(1,1,0,.5), \"black\", rgb(1,0,0,.75)),\n             xlab=\"\", sub=\"x\", lwd=c(1.2,1.2,1.2,1.5,2))\n    text(x=0.25, y=0.69, labels = text[1], cex = 0.8)\n    for (t in 2:length(text)) text(x=0.15*(t-1), y=0.65, labels = text[t], cex = 0.8) \n    legend(x = .6, y = .63, legend = c(\"RAIN\", \"SNOW\"), col=c(rgb(0,0,1,.75), rgb(1,1,0,.5)), lwd=3, bty = \"n\", horiz = T, )\n    \n  } else {\n    meteo_Q <- merge(meteo[,c(1,2,3)], discharge_daily[,c(1)])\n    plot.zoo(meteo_Q, ylab=c(\"Tair [°C]\", \"P [mm]\", \"Q [m^3/s]\"), screens = c(1,2,2,3), main=\"Basin Mean Meteo , Discharge\", \n             type=c(\"l\",\"h\",\"h\",\"l\"), col=c(grey(.2,.5), rgb(0,0,1,.75), rgb(1,1,0,.5), \"black\"),\n             xlab=\"\", sub=\"x\", lwd=c(1.2,1.2,1.2,1.5))\n    text(x=0.25, y=0.69, labels = text[1], cex = 0.8)\n    for (t in 2:length(text)) text(x=0.15*(t-1), y=0.65, labels = text[t], cex = 0.8) \n    legend(x = .6, y = .63, legend = c(\"RAIN\", \"SNOW\"), col=c(rgb(0,0,1,.75), rgb(1,1,0,.5)), lwd=3, bty = \"n\", horiz = T, )\n    \n  }\n\n  meteo_month <- aggregate(x = meteo, by = as.yearmon(time(meteo)))\n  \n  Psnow_month <- meteo_month$P_snow\n  Prain_month <- meteo_month$P - meteo_month$P_snow\n\n  Psnow_perc  <- Psnow_month / meteo_month$P *100\n  Prain_perc  <- Prain_month / meteo_month$P *100\n  \n  op <- par(mfrow=c(2,1))  \n  \n  barplot(merge(Prain_month,Psnow_month), col=c(rgb(0,0,1,.75), rgb(1,1,0,.5)), beside = F, ylab=\"mm/month\", \n          main=\"Monthly Partitioning Precipitation\")\n  legend(\"topleft\", legend = c( \"Snow\", \"Rainfall\"), col=c(rgb(1,1,0,.5), rgb(0,0,1,.75)), \n         pch=15, horiz=F, bty=\"n\")\n  barplot(merge(Prain_perc,Psnow_perc), col=c(rgb(0,0,1,.75), rgb(1,1,0,.5)), beside = F, ylab=\"%\")\n  legend(\"topleft\", legend = c( \"Snow\", \"Rainfall\"), col=c(rgb(1,1,0,.5), rgb(0,0,1,.75)), \n         pch=15, horiz=F, bty=\"n\")\n  \n  par(op)\n\n  dev.off()\n\n#2 discharge observed vs. simulated\n  if (Q_obs==\"day\" | Q_obs==\"hour\")\n  {\n    pdf(paste(wpath,\"QsimVSQobs.pdf\",sep=\"\"), width = 21)\n    \n    if (Q_obs==\"hour\")\n    {\n      plot.zoo(discharge_hourly[,c(1,2)], screens = c(1,1), lwd=c(1.5,2), col=c(\"black\", rgb(1,0,0,.75)),\n               ylab=\"Q [m^3/s]\", main=\"time resolution , hour\")\n      legend(\"topright\", legend = c(\"observerd\", \"simulated\"), lwd=3, bty=\"n\", col=c(\"black\", rgb(1,0,0,.75)))\n      \n      ggof(sim = discharge_hourly[,2], obs = discharge_hourly[,1],   \n           gofs = c(\"RMSE\", \"NSE\", \"R2\"),\n           legend = c(\"simulated\", \"observed\"))\n    }\n    \n    plot.zoo(discharge_daily[,c(1,2)], screens = c(1,1), lwd=c(1.5,2), col=c(\"black\", rgb(1,0,0,.75)),\n             ylab=\"Q [m^3/s]\", main=\"time resolution , day\")\n    legend(\"topright\", legend = c(\"observerd\", \"simulated\"), lwd=3, bty=\"n\", col=c(\"black\", rgb(1,0,0,.75)))\n    plot.zoo(discharge_month[,c(1,2)], screens = c(1,1), lwd=c(1.5,2), col=c(\"black\", rgb(1,0,0,.75)),\n             ylab=\"Q [m^3/s]\", main=\"time resolution , month\")\n    legend(\"topright\", legend = c(\"observerd\", \"simulated\"), lwd=3, bty=\"n\", col=c(\"black\", rgb(1,0,0,.75)))\n    \n    ggof(sim = discharge_daily[,2], obs = discharge_daily[,1], ftype = \"dm\", FUN=mean, \n         gofs = c(\"RMSE\", \"NSE\", \"R2\"),\n         legend = c(\"simulated\", \"observed\"))\n    \n#     # analysis and visualisation of residuals (simulated - observed)\n#     r <- discharge_hourly[,2] - discharge_hourly[,1]\n#     r <- r[!is.na(coredata(r)),]\n#     names(r) <- \"residuals Q\"\n#     hydroplot(r, FUN=mean)\n    \n    dev.off()\n    \n  }\n\n#3.1 basin water badget / mass balance\n\n# visualize dS/dt = P - ET - Q\n  delta_S1 <- P - Q_sim_mm - ET - Q_out_mm_day\n\n  delta <- merge(dBudget=delta_S1, dStorage=delta_S)\n\n  pdf(paste(wpath,\"WaterBudget.pdf\",sep=\"\"), width = 21)\n\n  plot.zoo(delta, screens = c(1,1), col=c(\"black\", rgb(1,0,0,.5)), lwd=c(2,2), type = c(\"l\",\"l\"), \n           ylab=\"mm\", main=\"dS/dt = P - ET - Q\")\n  abline(h=seq(from = -100,100,by = 10), col=grey.colors(n = 1,.5,.5,alpha = .3), lwd=.5)\n  abline(h=0, col=rgb(0,1,0,.5), lwd=2, lty=\"dashed\")\n  legend(\"topleft\", legend = c(\"P - ET - Q\", \"dS/dt\"), col=c(\"black\", rgb(1,0,0,.5)), lwd=2)\n\n# visualize cumulated main components and total storage\n\n  mainComponents <- merge(P=P, ET=-ET, Q=-Q_sim_mm, Q_out=-Q_out_mm_day)\n  \n  if (length(which(is.na(mainComponents[,1]))) > 0) mainComponents <- mainComponents[-which(is.na(mainComponents[,1])),]\n  cumsumMainComp <- cumsum(mainComponents)\n\n  cumsumMainComp_Budget <- cumsumMainComp$P + cumsumMainComp$Q + cumsumMainComp$ET + cumsumMainComp$Q_out\n  \n  Storage <- S-coredata(S[1,1])\n\n  forplot <- merge(cumsumMainComp, Budget=cumsumMainComp_Budget, Storage=Storage)\n  \n  col <- rainbow(n = dim(forplot)[2])\n\n  plot.zoo(x = forplot, screens = rep(1,dim(forplot)[2]), col=col, \n           main=\"dS/dt = P - ET - Q , integral\", ylab=\"mm\")\n  legend(\"topleft\", legend = names(forplot), col=col, lwd=3, ncol=3, bty=\"n\")\n  abline(h=seq(-10000,10000,1000), col=grey.colors(n = 1, start = .5, end = .5, alpha = .25))\n  abline(h=0,  col=grey.colors(n = 1, start = .25, end = .25, alpha = .25))\n\n# 3.2 budget/storage residuals\n\n  res_total <- forplot$Storage - forplot$Budget\n  res_dt    <- delta$dStorage - delta$dBudget\n  residuals <- merge(res_dt, res_total)\n  plot.zoo(residuals, panel = function(x, y, col, lty, ...) {\n    lines(x, y, ...)\n    abline(h=0, lty=\"dashed\", col=rgb(1,0,0,.5))\n  }, ylab=c(\"dt [mm]\", \"integral [mm]\"), main=\"Residuals , Storage - Budget\")\n\n# 3.3 storage terms\n\n# dynamics of total storage\n  plot.zoo(x = totalStorage, main=\"Main Storage Components , mm\", lwd=1.5)\n  plot.zoo(x = dS, main=\"dS/dt , Change in Storage Conponents , mm/day\", lwd=1.5)\n\n# soil water storage in soil layers\n  plot.zoo(totalSMC_mm, ylab=soil_spez, main=\"Soil Water Storage per Layer , mm\", panel = function(x,y,...)\n    {\n      panel.number <- parent.frame()$panel.number\n      lines(x, y, ylim=c(0, layer_saturation[panel.number]+.1*layer_saturation[panel.number]))\n      abline(h=layer_saturation[panel.number], col=rgb(0,0,1,.5), lwd=2, lty=\"dashed\")\n    })\n  legend(\"bottomleft\", legend = \"saturated\", lty=\"dashed\", lwd=3, col=rgb(0,0,1,.5))\n\n# 3.5 Snow and Ice melt dynamics, Snow and Ice storage partitioning\n  if (!is.null(name_swe))\n  {\n    SWE_comp <- merge(diffSWE_mm, diffSWE_mm_glacier, diffSWE_mm_snow, totalSWE_mm, totalSWE_mm_glacier, totalSWE_mm_snow)\n    \n    # dynamics\n    plot.zoo(SWE_comp[,c(1:3)], screens=c(1,1,1), col=c(\"grey30\", rgb(0,1,0,.75), rgb(1,0,0,.5)), lwd=c(3,2,2), ylab=\"mm\")\n    abline(h = 0, col=grey.colors(n = 1, start = .5, end = .5, alpha = .5), lwd=2, lty=\"dashed\")\n    legend(\"topleft\", legend = c(\"mean change SWE storage\", \"mean change ice/glacier storage\", \"mean change snow storage\"), \n           lwd=3, col=c(\"grey\", rgb(0,1,0,.75), rgb(1,0,0,.5)))\n    \n    # melt partitioning storage\n    SWE_comp_month <- aggregate(x = SWE_comp, by = as.yearmon(time(SWE_comp)), FUN = sum)\n    \n    SWE_melt <- zoo(apply(X = SWE_comp[,1:3], MARGIN = 2, FUN = function(x) ifelse(SWE_comp[,1]>=0, NA, x)), time(SWE_comp))\n    SWE_stor <- zoo(apply(X = SWE_comp[,1:3], MARGIN = 2, FUN = function(x) ifelse(SWE_comp[,1]<0, NA, x)), time(SWE_comp))\n    \n    SWE_melt_month <- aggregate(x = SWE_melt, by = as.yearmon(time(SWE_comp)), FUN = sum, na.rm=T)\n    SWE_stor_month <- aggregate(x = SWE_stor, by = as.yearmon(time(SWE_comp)), FUN = sum, na.rm=T)\n    \n    SWE_melt_glac_perc <- SWE_melt_month[,2] / SWE_melt_month[,1] *100\n    SWE_melt_snow_perc <- SWE_melt_month[,3] / SWE_melt_month[,1] *100\n    \n    barplot(SWE_comp_month[,c(2,3)], col=c(rgb(0,1,0,.5), rgb(1,0,0,.5)), beside = T, ylab=\"mm/month\",\n            main=\"Monthly Partitioning Melt / Buildup , Contribution snow and ice\")\n    legend(\"topleft\", legend = c( \"Snow\", \"Ice\"), col=c(rgb(1,0,0,.5), rgb(0,1,0,.5)), \n           pch=15, horiz=F)\n    \n    barplot(merge(SWE_melt_glac_perc, SWE_melt_snow_perc), col=c(rgb(0,1,0,.5),rgb(1,0,0,.5)), \n            pch=15, bty=\"n\", horiz=F, ylab=\"%\", beside=F, main = \"Contribution to melt water production\")\n    legend(\"topleft\", legend = c( \"Snow\", \"Ice\"), col=c(rgb(1,0,0,.5),rgb(0,1,0,.5)), \n           pch=15, horiz=F)\n  }\n\n    \n# 3.4 ET partitioning\n  ET_part <- merge(ET=ET, Evaporation=Evap_surface, Transpiration=Trans_canopy)\n  ET_part_cumsum <- cumsum(ET_part)\n\n  ET_part_month <- aggregate(x = ET_part, by = as.yearmon(time(ET_part)), FUN = sum)\n  ET_part_T_perc <- ET_part_month$Transpiration / ET_part_month$ET *100\n  ET_part_E_perc <- ET_part_month$Evaporation / ET_part_month$ET *100\n\n#   ET_part_perc <- merge( E = ET_part_cumsum$Evaporation / ET_part_cumsum$ET *100, \n#                          T = ET_part_cumsum$Transpiration / ET_part_cumsum$ET *100)\n\n  plot.zoo(ET_part_cumsum, screens=c(1,1,1), main=\"Partitioning Evapotranspiration\",\n           col=c(\"grey10\", rgb(1,0,0,.75), rgb(0,1,0,.75)), ylab=\"mm\")\n  legend(\"topleft\", legend = c(\"Evapotranspiration\", \"Evaporation\", \"Transpration\"), \n         col=c(\"grey10\", rgb(1,0,0,.75), rgb(0,1,0,.75)), lwd=3, bty=\"n\")\n\n  op <- par(mfrow=c(2,1))  \n\n  barplot(ET_part_month[,c(2,3)], col=c(rgb(1,0,0,.5), rgb(0,1,0,.5)), beside = F, ylab=\"mm/month\", \n          main=\"Monthly Partitioning Evapotranspiration\")\n  legend(\"topleft\", legend = c( \"Transpiration\", \"Evaporation\"), col=c(rgb(0,1,0,.5), rgb(1,0,0,.5)), \n         pch=15, horiz=F)\n  barplot(merge(ET_part_E_perc, ET_part_T_perc), col=c(rgb(1,0,0,.5), rgb(0,1,0,.5)), \n          pch=15, bty=\"n\", horiz=F, ylab=\"Percent\")\n  legend(\"topleft\", legend = c( \"Transpiration\", \"Evaporation\"), col=c(rgb(0,1,0,.5), rgb(1,0,0,.5)), \n         pch=15, horiz=F)\n\n  par(op)\n\ndev.off()\n}",
    "created" : 1427363187308.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3038998753",
    "id" : "6433E978",
    "lastKnownWriteTime" : 1427367714,
    "path" : "~/GitHub/AnalyseGEOtop/R/GEOtop_CheckHydroBudget.R",
    "project_path" : "R/GEOtop_CheckHydroBudget.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}